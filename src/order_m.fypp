! Module   : order_m
! Purpose  : sorting and searching
!
! Copyright 2021 Rich Townsend
!
! This file is part of the ForUM (Fortran Utility Modules)
! package. ForUM is free software: you can redistribute it and/or
! modify it under the terms of the GNU General Public License as
! published by the Free Software Foundation, version 3.
!
! ForUM is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'forum.inc'

module order_m

   ! Uses

   use kinds_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Interfaces

   interface sort_indices
      #:for suffix in ORDERED_SUFFIXES
         module procedure sort_indices_${suffix}$_
      #:endfor
   end interface sort_indices

   interface unique_indices
      #:for suffix in ORDERED_SUFFIXES
         module procedure unique_indices_${suffix}$_
      #:endfor
   end interface unique_indices

   interface locate
      #:for suffix in ORDERED_SUFFIXES
         module procedure locate_${suffix}$_
      #:endfor
      #:for suffix in REAL_SUFFIXES
         module procedure locate_uniform_${suffix}$_
      #:endfor
   end interface locate

   ! Access specifiers

   private

   public :: sort_indices
   public :: unique_indices
   public :: locate

   ! Procedures

contains

   #:for type, suffix in zip(ORDERED_TYPES, ORDERED_SUFFIXES)

      function sort_indices_${suffix}$_(x, descend) result (indices)

         ${type}$, intent(in)          :: x(:)
         logical, optional, intent(in) :: descend
         integer                       :: indices(SIZE(x))

         integer :: N
         integer :: L(0:SIZE(x)+1)
         integer :: i
         integer :: p
         integer :: q
         integer :: s
         integer :: t

         ! Calculate the indices to sort x in ascending order (or
         ! descending, if descend is .TRUE.).
         !
         ! This routine uses the List Merge Sort algorithm described by
         ! Knuth (1998, The Art of Computer Programming Vol. 3, Addison-
         ! Wesley, Massachusetts, 3rd edn.). Labels and variable names
         ! deliberately follow those of Knuth (apart from K() -> x())

         N = SIZE(x)

         ! Special casing if N is 0 or 1; Knuth assumes N >= 2

         if (N == 0) then
            return
         elseif (N == 1) then
            indices(1) = 1
            return
         end if

         ! L1 : Prepare two lists

         L(0) = 1
         L(1:N-2) = [(-(i+2), i=1,N-2)]
         L(N-1:N) = 0
         L(N+1) = 2

         ! L2 : Begin new pass

         L2_loop : do

            s = 0
            t = N + 1

            p = L(s)
            q = L(t)

            if (q == 0) exit L2_loop

            ! L3 : Compare K_p:K_q

            L3_loop : do

               if (x(p) > x(q)) then

                  ! L6 : Advance q

                  L(s) = SIGN(q, L(s))
                  s = q
                  q = L(q)

                  if (q > 0) cycle L3_loop

                  ! L7 : Complete the sublist

                  L(s) = p
                  s = t

                  L7_loop : do

                     t = p
                     p = L(p)

                     if (p <= 0) exit L7_loop

                  end do L7_loop

               else

                  ! L4 : Advance q

                  L(s) = SIGN(p, L(s))
                  s = p
                  p = L(p)

                  if (p > 0) cycle L3_loop

                  ! L5 : Complete the sublist

                  L(s) = q
                  s = t

                  L5_loop : do

                     t = q
                     q = L(q)

                     if (q <= 0) exit L5_loop

                  end do L5_loop

               end if

               ! L8 : End of pass?

               p = -p
               q = -q

               if (q == 0) then
                  L(s) = SIGN(p, L(s))
                  L(t) = 0
                  exit L3_loop
               endif

            end do L3_loop

         end do L2_loop

         ! Use the link list to set up the indices array

         indices(1) = L(0)

         do i = 2,N
            indices(i) = L(indices(i-1))
         enddo

         ! If necessary, reverse the indices

         if (PRESENT(descend)) then
            if (descend) indices = indices(N:1:-1)
         endif

         ! Finish

         return

      end function sort_indices_${suffix}$_

   #:endfor

   !****

   #:for type, suffix in zip(ORDERED_TYPES, ORDERED_SUFFIXES)

      function unique_indices_${suffix}$_(x, descend) result (indices)

         ${type}$, intent(in)          :: x(:)
         logical, optional, intent(in) :: descend
         integer, allocatable          :: indices(:)

         integer :: indices_(SIZE(x))
         integer :: n
         integer :: i

         ! Calculate indices to sort x in increasing order and then
         ! select unique values

         indices_ = sort_indices(x)

         n = 1

         do i = 2,SIZE(x)
            if (x(indices_(i)) /= x(indices_(n))) then
               n = n + 1
               indices_(n) = indices_(i)
            endif
         end do

         indices = indices_(:n)

         ! If necessary, reverse the indices

         if (PRESENT(descend)) then
            if (descend) indices = indices(n:1:-1)
         endif

         ! Finish

         return

      end function unique_indices_${suffix}$_

   #:endfor

   !****

   #:for type, suffix in zip(ORDERED_TYPES, ORDERED_SUFFIXES)

      subroutine locate_${suffix}$_(x, x_loc, i_loc)

         ${type}$, intent(in) :: x(:)
         ${type}$, intent(in) :: x_loc
         integer, intent(out) :: i_loc

         integer       :: n
         integer, save :: i_lo = 1
         integer, save :: i_hi = 1
         integer       :: di
         integer       :: i_mid

         !$OMP THREADPRIVATE (i_lo, i_hi)

         ! Use a binary search to find where x_loc falls in x (assumed to
         ! be in ascending order); x(i_loc) <= x_loc <= x(i_loc+1), with
         ! the right equality applying only when i_loc == n

         n = SIZE(x)

         if (x_loc == x(n)) then

            i_loc = n - 1

         elseif (x_loc == x(1)) then

            i_loc = 1

         else

            if (i_lo <= 0 .OR. i_lo >= n) then

               i_lo = 0
               i_hi = n

            else

               di = 1

               if (x_loc >= x(i_lo)) then

                  search_up_loop : do

                     i_hi = i_lo + di

                     if (i_hi > n) then
                        i_hi = n + 1
                        exit search_up_loop
                     endif

                     if (x_loc < x(i_hi)) exit search_up_loop

                     i_lo = i_hi
                     di = 2*di

                  end do search_up_loop

               else

                  search_down_loop : do

                     i_hi = i_lo
                     i_lo = i_hi - di

                     if (i_lo < 1) then
                        i_lo = 0
                        exit search_down_loop
                     endif

                     if (x_loc >= x(i_lo)) exit search_down_loop

                  end do search_down_loop

               endif

            endif

            refine_loop : do

               if (i_hi-i_lo <= 1) exit refine_loop

               i_mid = (i_hi + i_lo)/2

               if (x_loc >= x(i_mid)) then
                  i_lo = i_mid
               else
                  i_hi = i_mid
               endif

            end do refine_loop

            i_loc = i_lo

         endif

         ! Finish

         return

      end subroutine locate_${suffix}$_

   #:endfor

   !****

   #:for type, suffix in zip(REAL_TYPES, REAL_SUFFIXES)

      subroutine locate_uniform_${suffix}$_(x_0, dx, x_loc, i_loc)

         ${type}$, intent(in) :: x_0
         ${type}$, intent(in) :: dx
         ${type}$, intent(in) :: x_loc
         integer, intent(out) :: i_loc

         ! Determine i_loc so that x_0 + (i_loc-1)*dx <= x_loc < x_0 + i_loc*dx

         i_loc = FLOOR((x_loc - x_0)/dx) + 1

         if (x_0 + (i_loc-1)*dx > x_loc) i_loc = i_loc - 1
         if (x_0 + i_loc*dx <= x_loc) i_loc = i_loc + 1

         ! Finish

         return

      end subroutine locate_uniform_${suffix}$_

   #:endfor

end module order_m
